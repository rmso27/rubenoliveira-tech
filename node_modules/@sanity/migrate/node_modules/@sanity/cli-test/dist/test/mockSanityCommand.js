/**
 * Creates a testable subclass of a command with mocked SanityCommand dependencies.
 *
 * @example
 * ```ts
 * // Basic config mocking
 * const TestAdd = mockSanityCommand(Add, {
 *   cliConfig: { api: { projectId: 'test-project' } }
 * })
 *
 * // With mock API client
 * const mockClient = {
 *   getDocument: vi.fn().mockResolvedValue({ _id: 'doc1', title: 'Test' }),
 *   fetch: vi.fn().mockResolvedValue([]),
 * }
 * const TestGet = mockSanityCommand(GetDocumentCommand, {
 *   cliConfig: { api: { projectId: 'test-project', dataset: 'production' } },
 *   projectApiClient: mockClient,
 * })
 *
 * const {stdout} = await testCommand(TestGet, ['doc1'])
 * expect(mockClient.getDocument).toHaveBeenCalledWith('doc1')
 * ```
 */ export function mockSanityCommand(CommandClass, options = {}) {
    // Create a subclass that overrides methods when mocks are provided
    // Note: we use @ts-expect-error because TypeScript can't properly infer
    // the relationship between the generic CommandClass and SanityCommand
    // @ts-expect-error - TypeScript struggles with abstract class subclassing
    class MockedCommand extends CommandClass {
        getCliConfig() {
            if (options.cliConfig) {
                return Promise.resolve(options.cliConfig);
            }
            return super.getCliConfig();
        }
        getProjectRoot() {
            if (options.projectRoot) {
                return Promise.resolve(options.projectRoot);
            }
            return super.getProjectRoot();
        }
        resolveIsInteractive() {
            if (options.isInteractive !== undefined) {
                return options.isInteractive;
            }
            return super.resolveIsInteractive();
        }
    }
    return MockedCommand;
}

//# sourceMappingURL=mockSanityCommand.js.map