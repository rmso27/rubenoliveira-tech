{"version":3,"sources":["../../src/test/captureOutput.ts"],"sourcesContent":["import {type Errors} from '@oclif/core'\nimport ansis from 'ansis'\n\nexport interface CaptureOptions {\n  /**\n   * Whether to print the output to the console\n   */\n  print?: boolean\n  /**\n   * Whether to strip ANSI escape codes from the output\n   */\n  stripAnsi?: boolean\n  testNodeEnv?: string\n}\n\nexport interface CaptureResult<T = unknown> {\n  stderr: string\n  stdout: string\n\n  error?: Error & Partial<Errors.CLIError>\n  result?: T\n}\n\n/**\n * Capture the output of a command and return the result\n *\n * @param fn - The function to capture the output of\n * @param opts - The options for the capture\n * @returns The result of the command\n * @internal\n *\n * Credits to oclif for the original implementation:\n * https://github.com/oclif/test/blob/2a5407e6fc80d388043d10f6b7b8eaa586483015/src/index.ts\n *\n * We are not using the library directly since it does not support mocking code inside of the command\n * possibly because the commands run in a different thread\n */\nexport async function captureOutput<T>(\n  fn: () => Promise<T>,\n  opts?: CaptureOptions,\n): Promise<CaptureResult<T>> {\n  const print = opts?.print ?? false\n  const stripAnsi = opts?.stripAnsi ?? true\n  const testNodeEnv = opts?.testNodeEnv || 'test'\n\n  const originals = {\n    NODE_ENV: process.env.NODE_ENV,\n    stderrWrite: process.stderr.write,\n    stdoutWrite: process.stdout.write,\n  }\n\n  const output: Record<'stderr' | 'stdout', string[]> = {\n    stderr: [],\n    stdout: [],\n  }\n\n  const toString = (str: string | Uint8Array): string =>\n    stripAnsi ? ansis.strip(str.toString()) : str.toString()\n\n  const getStderr = (): string => output.stderr.map((b) => toString(b)).join('')\n  const getStdout = (): string => output.stdout.map((b) => toString(b)).join('')\n\n  const mockWrite =\n    (std: 'stderr' | 'stdout'): typeof process.stderr.write =>\n    (\n      chunk: string | Uint8Array,\n      encodingOrCb?: ((err?: Error | null) => void) | BufferEncoding,\n      cb?: (err?: Error | null) => void,\n    ) => {\n      output[std].push(chunk.toString())\n\n      if (print) {\n        let callback: ((err?: Error | null) => void) | undefined = cb\n        let encoding: BufferEncoding | undefined\n        if (typeof encodingOrCb === 'function') {\n          callback = encodingOrCb\n        } else {\n          encoding = encodingOrCb\n        }\n        originals[`${std}Write`].apply(process[std], [chunk, encoding, callback])\n      } else if (typeof cb === 'function') {\n        cb()\n      } else if (typeof encodingOrCb === 'function') {\n        encodingOrCb()\n      }\n      return true\n    }\n\n  process.stdout.write = mockWrite('stdout')\n  process.stderr.write = mockWrite('stderr')\n  process.env.NODE_ENV = testNodeEnv\n\n  try {\n    const result = await fn()\n    return {\n      result,\n      stderr: getStderr(),\n      stdout: getStdout(),\n    }\n  } catch (error) {\n    // Check if it's an oclif CLIError or a regular error\n    const processedError =\n      error instanceof Error // Check if it's an Error (this includes CLIError)\n        ? Object.assign(error, {message: toString(error.message)}) // If so, process its message\n        : new Error(toString(String(error))) // Otherwise, create a new Error from string representation\n\n    return {\n      error: processedError,\n      stderr: getStderr(),\n      stdout: getStdout(),\n    }\n  } finally {\n    process.stdout.write = originals.stdoutWrite\n    process.stderr.write = originals.stderrWrite\n    process.env.NODE_ENV = originals.NODE_ENV\n  }\n}\n"],"names":["ansis","captureOutput","fn","opts","print","stripAnsi","testNodeEnv","originals","NODE_ENV","process","env","stderrWrite","stderr","write","stdoutWrite","stdout","output","toString","str","strip","getStderr","map","b","join","getStdout","mockWrite","std","chunk","encodingOrCb","cb","push","callback","encoding","apply","result","error","processedError","Error","Object","assign","message","String"],"mappings":"AACA,OAAOA,WAAW,QAAO;AAsBzB;;;;;;;;;;;;;CAaC,GACD,OAAO,eAAeC,cACpBC,EAAoB,EACpBC,IAAqB;IAErB,MAAMC,QAAQD,MAAMC,SAAS;IAC7B,MAAMC,YAAYF,MAAME,aAAa;IACrC,MAAMC,cAAcH,MAAMG,eAAe;IAEzC,MAAMC,YAAY;QAChBC,UAAUC,QAAQC,GAAG,CAACF,QAAQ;QAC9BG,aAAaF,QAAQG,MAAM,CAACC,KAAK;QACjCC,aAAaL,QAAQM,MAAM,CAACF,KAAK;IACnC;IAEA,MAAMG,SAAgD;QACpDJ,QAAQ,EAAE;QACVG,QAAQ,EAAE;IACZ;IAEA,MAAME,WAAW,CAACC,MAChBb,YAAYL,MAAMmB,KAAK,CAACD,IAAID,QAAQ,MAAMC,IAAID,QAAQ;IAExD,MAAMG,YAAY,IAAcJ,OAAOJ,MAAM,CAACS,GAAG,CAAC,CAACC,IAAML,SAASK,IAAIC,IAAI,CAAC;IAC3E,MAAMC,YAAY,IAAcR,OAAOD,MAAM,CAACM,GAAG,CAAC,CAACC,IAAML,SAASK,IAAIC,IAAI,CAAC;IAE3E,MAAME,YACJ,CAACC,MACD,CACEC,OACAC,cACAC;YAEAb,MAAM,CAACU,IAAI,CAACI,IAAI,CAACH,MAAMV,QAAQ;YAE/B,IAAIb,OAAO;gBACT,IAAI2B,WAAuDF;gBAC3D,IAAIG;gBACJ,IAAI,OAAOJ,iBAAiB,YAAY;oBACtCG,WAAWH;gBACb,OAAO;oBACLI,WAAWJ;gBACb;gBACArB,SAAS,CAAC,GAAGmB,IAAI,KAAK,CAAC,CAAC,CAACO,KAAK,CAACxB,OAAO,CAACiB,IAAI,EAAE;oBAACC;oBAAOK;oBAAUD;iBAAS;YAC1E,OAAO,IAAI,OAAOF,OAAO,YAAY;gBACnCA;YACF,OAAO,IAAI,OAAOD,iBAAiB,YAAY;gBAC7CA;YACF;YACA,OAAO;QACT;IAEFnB,QAAQM,MAAM,CAACF,KAAK,GAAGY,UAAU;IACjChB,QAAQG,MAAM,CAACC,KAAK,GAAGY,UAAU;IACjChB,QAAQC,GAAG,CAACF,QAAQ,GAAGF;IAEvB,IAAI;QACF,MAAM4B,SAAS,MAAMhC;QACrB,OAAO;YACLgC;YACAtB,QAAQQ;YACRL,QAAQS;QACV;IACF,EAAE,OAAOW,OAAO;QACd,qDAAqD;QACrD,MAAMC,iBACJD,iBAAiBE,MAAM,kDAAkD;WACrEC,OAAOC,MAAM,CAACJ,OAAO;YAACK,SAASvB,SAASkB,MAAMK,OAAO;QAAC,GAAG,6BAA6B;WACtF,IAAIH,MAAMpB,SAASwB,OAAON,SAAS,2DAA2D;;QAEpG,OAAO;YACLA,OAAOC;YACPxB,QAAQQ;YACRL,QAAQS;QACV;IACF,SAAU;QACRf,QAAQM,MAAM,CAACF,KAAK,GAAGN,UAAUO,WAAW;QAC5CL,QAAQG,MAAM,CAACC,KAAK,GAAGN,UAAUI,WAAW;QAC5CF,QAAQC,GAAG,CAACF,QAAQ,GAAGD,UAAUC,QAAQ;IAC3C;AACF"}