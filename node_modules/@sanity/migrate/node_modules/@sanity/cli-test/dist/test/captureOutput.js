import ansis from 'ansis';
/**
 * Capture the output of a command and return the result
 *
 * @param fn - The function to capture the output of
 * @param opts - The options for the capture
 * @returns The result of the command
 * @internal
 *
 * Credits to oclif for the original implementation:
 * https://github.com/oclif/test/blob/2a5407e6fc80d388043d10f6b7b8eaa586483015/src/index.ts
 *
 * We are not using the library directly since it does not support mocking code inside of the command
 * possibly because the commands run in a different thread
 */ export async function captureOutput(fn, opts) {
    const print = opts?.print ?? false;
    const stripAnsi = opts?.stripAnsi ?? true;
    const testNodeEnv = opts?.testNodeEnv || 'test';
    const originals = {
        NODE_ENV: process.env.NODE_ENV,
        stderrWrite: process.stderr.write,
        stdoutWrite: process.stdout.write
    };
    const output = {
        stderr: [],
        stdout: []
    };
    const toString = (str)=>stripAnsi ? ansis.strip(str.toString()) : str.toString();
    const getStderr = ()=>output.stderr.map((b)=>toString(b)).join('');
    const getStdout = ()=>output.stdout.map((b)=>toString(b)).join('');
    const mockWrite = (std)=>(chunk, encodingOrCb, cb)=>{
            output[std].push(chunk.toString());
            if (print) {
                let callback = cb;
                let encoding;
                if (typeof encodingOrCb === 'function') {
                    callback = encodingOrCb;
                } else {
                    encoding = encodingOrCb;
                }
                originals[`${std}Write`].apply(process[std], [
                    chunk,
                    encoding,
                    callback
                ]);
            } else if (typeof cb === 'function') {
                cb();
            } else if (typeof encodingOrCb === 'function') {
                encodingOrCb();
            }
            return true;
        };
    process.stdout.write = mockWrite('stdout');
    process.stderr.write = mockWrite('stderr');
    process.env.NODE_ENV = testNodeEnv;
    try {
        const result = await fn();
        return {
            result,
            stderr: getStderr(),
            stdout: getStdout()
        };
    } catch (error) {
        // Check if it's an oclif CLIError or a regular error
        const processedError = error instanceof Error // Check if it's an Error (this includes CLIError)
         ? Object.assign(error, {
            message: toString(error.message)
        }) // If so, process its message
         : new Error(toString(String(error))) // Otherwise, create a new Error from string representation
        ;
        return {
            error: processedError,
            stderr: getStderr(),
            stdout: getStdout()
        };
    } finally{
        process.stdout.write = originals.stdoutWrite;
        process.stderr.write = originals.stderrWrite;
        process.env.NODE_ENV = originals.NODE_ENV;
    }
}

//# sourceMappingURL=captureOutput.js.map