/**
 * Vitest worker setup for the Sanity CLI.
 *
 * This builds the worker TS files into JS files using esbuild bundling.
 * All internal dependencies are bundled inline, while npm packages remain external.
 */ import { unlink } from 'node:fs/promises';
import { build, context } from 'esbuild';
const compiledFiles = new Set();
let buildContexts = [];
/**
 * Generate esbuild configuration for bundling worker files.
 *
 * @param filePath - The worker file path to bundle
 * @param outputFile - The output file path for the bundled worker
 * @returns esbuild configuration object
 */ function esbuildOptions(filePath, outputFile) {
    return {
        bundle: true,
        conditions: [
            'node',
            'import'
        ],
        entryPoints: [
            filePath
        ],
        // Marks cli-core as external to avoid bundling it inline
        // this is mostly necessary for the monorepo.
        external: [
            '@sanity/cli-core'
        ],
        format: 'esm',
        loader: {
            '.json': 'json'
        },
        logLevel: 'warning',
        mainFields: [
            'module',
            'main'
        ],
        outfile: outputFile,
        packages: 'external',
        platform: 'node',
        sourcemap: false,
        target: 'node20'
    };
}
/**
 * Bundle a single worker file with esbuild.
 *
 * @param filePath - The worker file path to bundle
 * @param external - Array of package names to keep external
 * @returns The output file path
 */ async function bundleWorkerFile(filePath) {
    const outputFile = filePath.replace(/\.ts$/, '.js');
    await build(esbuildOptions(filePath, outputFile));
    compiledFiles.add(outputFile);
    return outputFile;
}
/**
 * Bundle all worker files with esbuild (non-watch mode).
 *
 * @param filePaths - Array of worker file paths to bundle
 */ async function setupBundling(filePaths) {
    console.log(`Found ${filePaths.length} worker files to bundle`);
    for (const workerFile of filePaths){
        try {
            await bundleWorkerFile(workerFile);
            console.log(`âœ“ Bundled ${workerFile}`);
        } catch (error) {
            console.error(`âœ— Failed to bundle ${workerFile}:`, error);
            throw error;
        }
    }
}
/**
 * Set up watch mode for worker files using esbuild's native watch API.
 *
 * @param files - Array of worker file paths to watch
 */ async function setupWatchMode(files) {
    for (const filePath of files){
        const outputFile = filePath.replace(/\.ts$/, '.js');
        const ctx = await context(esbuildOptions(filePath, outputFile));
        await ctx.watch();
        buildContexts.push(ctx);
        compiledFiles.add(outputFile);
        console.log(`ðŸ‘€ Watching ${filePath}`);
    }
}
/**
 * Setup function to build the worker files with esbuild.
 *
 * Bundles the worker files with esbuild and sets up watch mode if in watch mode.
 * All npm packages are automatically marked as external (loaded from node_modules at runtime).
 * Only internal project code is bundled inline.
 *
 * @param filePaths - The paths to the worker files to build
 * @returns A promise that resolves when the worker build is setup
 * @throws If the worker files cannot be bundled
 * @throws If the watcher cannot be set up
 */ export async function setupWorkerBuild(filePaths) {
    const isWatchMode = (process.env.VITEST_WATCH === 'true' || !process.argv.includes('run')) && process.env.CI !== 'true';
    await (isWatchMode ? setupWatchMode(filePaths) : setupBundling(filePaths));
}
/**
 * Teardown function to clean up the worker build.
 *
 * Closes all build contexts and deletes the compiled JavaScript files.
 *
 * @returns A promise that resolves when the worker build is teared down
 * @throws If the build contexts cannot be disposed
 * @throws If the compiled JavaScript files cannot be deleted
 */ export async function teardownWorkerBuild() {
    // Dispose all build contexts (for watch mode)
    for (const ctx of buildContexts){
        await ctx.dispose();
    }
    buildContexts = [];
    // Clean up compiled JavaScript files
    console.log('Cleaning up compiled JavaScript files...');
    for (const filePath of compiledFiles){
        try {
            await unlink(filePath);
            console.log(`âœ“ Deleted ${filePath}`);
        } catch (error) {
            console.error(`Failed to delete ${filePath}:`, error);
        }
    }
    compiledFiles.clear();
}

//# sourceMappingURL=vitestWorker.js.map