{"version":3,"sources":["../../../src/config/studio/readStudioConfig.worker.ts"],"sourcesContent":["import {pathToFileURL} from 'node:url'\nimport {isMainThread, parentPort, workerData} from 'node:worker_threads'\n\nimport {moduleResolve} from 'import-meta-resolve'\nimport {z} from 'zod'\n\nimport {doImport} from '../../util/doImport.js'\nimport {getEmptyAuth} from '../../util/getEmptyAuth.js'\nimport {safeStructuredClone} from '../../util/safeStructuredClone.js'\n\nif (isMainThread || !parentPort) {\n  throw new Error('Should only be run in a worker!')\n}\n\nconst {configPath, resolvePlugins} = z\n  .object({configPath: z.string(), resolvePlugins: z.boolean()})\n  .parse(workerData)\n\nlet {default: config} = await doImport(configPath)\n\nif (resolvePlugins) {\n  // If we need to resolve plugins, we need to import and use the `resolveConfig`\n  // function from the `sanity` package. This package should be installed in the users'\n  // studio project, not as part of the CLI - so we need to resolve the full path of the\n  // Sanity package relative to the studio.\n  const configUrl = pathToFileURL(configPath)\n\n  const sanityUrl = await moduleResolve('sanity', configUrl)\n  const {resolveConfig} = await doImport(sanityUrl.href)\n  if (typeof resolveConfig !== 'function') {\n    throw new TypeError('Expected `resolveConfig` from `sanity` to be a function')\n  }\n\n  // We'll want to use some observable tooling, but we'd prefer to use something\n  // compatible with what the studio uses internally, thus try to load RxJS from the\n  // sanity module path instead of installing it as a dependency locally.\n  const rxjsPath = (await moduleResolve('rxjs', sanityUrl)).href\n  const {firstValueFrom, of} = await doImport(rxjsPath)\n\n  // We will also want to stub out some configuration - we don't need to resolve the\n  // users' logged in state, for instance - so let's disable the auth implementation.\n  const workspaces = Array.isArray(config) ? config : [config]\n  workspaces.map((workspace) => {\n    workspace.auth = {state: of(getEmptyAuth())}\n  })\n\n  config = await firstValueFrom(resolveConfig(config))\n}\n\nparentPort.postMessage(safeStructuredClone(config))\n\n// Explicitly exit the process to avoid any dangling references from keeping\n// the process alive after resolving it's main task\nsetImmediate(() => {\n  process.exit(1)\n})\n"],"names":["pathToFileURL","isMainThread","parentPort","workerData","moduleResolve","z","doImport","getEmptyAuth","safeStructuredClone","Error","configPath","resolvePlugins","object","string","boolean","parse","default","config","configUrl","sanityUrl","resolveConfig","href","TypeError","rxjsPath","firstValueFrom","of","workspaces","Array","isArray","map","workspace","auth","state","postMessage","setImmediate","process","exit"],"mappings":"AAAA,SAAQA,aAAa,QAAO,WAAU;AACtC,SAAQC,YAAY,EAAEC,UAAU,EAAEC,UAAU,QAAO,sBAAqB;AAExE,SAAQC,aAAa,QAAO,sBAAqB;AACjD,SAAQC,CAAC,QAAO,MAAK;AAErB,SAAQC,QAAQ,QAAO,yBAAwB;AAC/C,SAAQC,YAAY,QAAO,6BAA4B;AACvD,SAAQC,mBAAmB,QAAO,oCAAmC;AAErE,IAAIP,gBAAgB,CAACC,YAAY;IAC/B,MAAM,IAAIO,MAAM;AAClB;AAEA,MAAM,EAACC,UAAU,EAAEC,cAAc,EAAC,GAAGN,EAClCO,MAAM,CAAC;IAACF,YAAYL,EAAEQ,MAAM;IAAIF,gBAAgBN,EAAES,OAAO;AAAE,GAC3DC,KAAK,CAACZ;AAET,IAAI,EAACa,SAASC,MAAM,EAAC,GAAG,MAAMX,SAASI;AAEvC,IAAIC,gBAAgB;IAClB,+EAA+E;IAC/E,qFAAqF;IACrF,sFAAsF;IACtF,yCAAyC;IACzC,MAAMO,YAAYlB,cAAcU;IAEhC,MAAMS,YAAY,MAAMf,cAAc,UAAUc;IAChD,MAAM,EAACE,aAAa,EAAC,GAAG,MAAMd,SAASa,UAAUE,IAAI;IACrD,IAAI,OAAOD,kBAAkB,YAAY;QACvC,MAAM,IAAIE,UAAU;IACtB;IAEA,8EAA8E;IAC9E,kFAAkF;IAClF,uEAAuE;IACvE,MAAMC,WAAW,AAAC,CAAA,MAAMnB,cAAc,QAAQe,UAAS,EAAGE,IAAI;IAC9D,MAAM,EAACG,cAAc,EAAEC,EAAE,EAAC,GAAG,MAAMnB,SAASiB;IAE5C,kFAAkF;IAClF,mFAAmF;IACnF,MAAMG,aAAaC,MAAMC,OAAO,CAACX,UAAUA,SAAS;QAACA;KAAO;IAC5DS,WAAWG,GAAG,CAAC,CAACC;QACdA,UAAUC,IAAI,GAAG;YAACC,OAAOP,GAAGlB;QAAe;IAC7C;IAEAU,SAAS,MAAMO,eAAeJ,cAAcH;AAC9C;AAEAf,WAAW+B,WAAW,CAACzB,oBAAoBS;AAE3C,4EAA4E;AAC5E,mDAAmD;AACnDiB,aAAa;IACXC,QAAQC,IAAI,CAAC;AACf"}