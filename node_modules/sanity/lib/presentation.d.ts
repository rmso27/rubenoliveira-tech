import {ActorRefFrom} from 'xstate'
import {ActorRefFromLogic} from 'xstate'
import {ClientPerspective} from '@sanity/client'
import {ComponentType} from 'react'
import {EventObject} from 'xstate'
import {InitialValueResolverContext} from '@sanity/types'
import {MetaObject} from 'xstate'
import {NonReducibleUnknown} from 'xstate'
import {Observable} from 'rxjs'
import {ObservableActorLogic} from 'xstate'
import {PreviewUrlResolver} from '@sanity/preview-url-secret/define-preview-url'
import {PromiseActorLogic} from 'xstate'
import {RefObject} from 'react'
import {SanityClient} from '@sanity/client'
import {SanityDocument} from '@sanity/types'
import {SanityDocumentLike} from '@sanity/types'
import {Serializable} from '@sanity/presentation-comlink'
import {SerializableArray} from '@sanity/presentation-comlink'
import {SerializableObject} from '@sanity/presentation-comlink'
import {SerializablePrimitive} from '@sanity/presentation-comlink'
import {StackablePerspective} from '@sanity/client'
import {StateMachine} from 'xstate'
import {ValidationMarker} from '@sanity/types'

/**
 * @hidden
 * @beta */
declare type BufferedDocumentEvent =
  | SnapshotEvent
  | DocumentRebaseEvent
  | DocumentMutationEvent
  | CommittedEvent

declare interface CheckPermissionInput {
  checkPermissionName: DocumentValuePermission
  document: Partial<SanityDocument> | null
}

/**
 * All possible URL search parameters used by the Presentation tool
 * @public
 */
export declare interface CombinedSearchParams
  extends StructureDocumentPaneParams, PresentationSearchParams {}

/**
 * @hidden
 * @beta */
declare interface CommittedEvent {
  type: 'committed'
}

/**
 * Represents the connection status between the Sanity Studio and Presentation's preview iframe.
 * @public
 */
export declare type ConnectionStatus = 'connected' | 'connecting' | 'reconnecting' | 'idle'

declare interface Context {
  url: URL | null
  error: Error | null
  visualEditingOverlaysEnabled: boolean
}

declare interface Context_2 {
  initialUrl: URL | null
  previewUrl: URL | null
  allowOrigins: URLPattern[] | null
  error: Error | null
  previewSearchParam: string | null
  previewUrlSecret: {
    secret: string
    expiresAt: Date
  } | null
  previewAccessSharingCreatePermission: PermissionCheckResult | null
  previewAccessSharingReadPermission: PermissionCheckResult | null
  previewAccessSharingUpdatePermission: PermissionCheckResult | null
  previewUrlSecretPermission: PermissionCheckResult | null
  previewMode: PreviewUrlPreviewMode | null
}

/**
 * Generic function type used in `DocumentResolver` definitions that receives a `DocumentResolverContext` and returns a computed value.
 * @param context - `DocumentResolverContext` containing route information (origin, params, path)
 * @returns Computed value based on the context (typically a string for filters or an object for parameters)
 * @public
 */
export declare type ContextFn<T> = (context: DocumentResolverContext) => T

/**
 * Define documents for a given location.
 * This function doesn't do anything itself, it is used to provide type information.
 * @param resolvers - resolvers that return documents.
 * @public
 */
export declare function defineDocuments(resolvers: DocumentResolver[]): typeof resolvers

/**
 * Define locations for a given document type.
 * This function doesn't do anything itself, it is used to provide type information.
 * @param resolver - resolver that return locations for a document.
 * @public
 */
export declare function defineLocations<K extends string>(
  resolver: DocumentLocationResolverObject<K> | DocumentLocationsState,
): typeof resolver

/**
 * @deprecated the `previewUrl.initial`, `previewUrl.allowOrigins` and `previewUrl.previewMode.enable` supports async functions that offer advanced control over how preview URLs are resolved
 * @public
 */
declare type DeprecatedPreviewUrlResolver = PreviewUrlResolver<SanityClient>

/**
 * Represents a document location
 * @public
 */
export declare interface DocumentLocation {
  /**
   * Title of the document
   */
  title: string
  /**
   * URL of the document location
   */
  href: string
}

/**
 * Function used for advanced document location resolution
 * @param params - Object with document `id` and document `type` properties
 * @param context - Object with `documentStore` property for creating listenQuery subscriptions
 * @returns Document location state, optionally as an Observable, or null/undefined if no locations are available
 * @public
 */
export declare type DocumentLocationResolver = (
  params: {
    id: string
    type: string
    version: string | undefined
    perspectiveStack: StackablePerspective[]
  },
  context: {
    documentStore: DocumentStore
  },
) =>
  | DocumentLocationsState
  | null
  | undefined
  | Observable<DocumentLocationsState | null | undefined>

/**
 * Document location resolver object
 * @public
 */
export declare type DocumentLocationResolverObject<K extends string = string> = {
  /**
   * Object for selecting document fields
   */
  select: Record<K, string>
  /**
   * Function that accepts a document with the selected fields and returns an optional document location state
   */
  resolve: (value: Record<K, any> | null) => DocumentLocationsState | null | undefined | void
}

/**
 * Object of document location resolver definitions per document type
 * @public
 */
export declare type DocumentLocationResolvers = Record<
  string,
  DocumentLocationResolverObject | DocumentLocationsState
>

/**
 * State for describing document locations or providing a message if locations are unavailable
 * @public
 */
export declare interface DocumentLocationsState {
  /**
   * Array of document locations
   */
  locations?: DocumentLocation[]
  /**
   * Message to display if locations are unavailable
   */
  message?: string
  /**
   * Tone of the message
   */
  tone?: 'positive' | 'caution' | 'critical'
}

/**
 * @hidden
 * @beta */
declare interface DocumentMutationEvent {
  type: 'mutation'
  document: SanityDocument
  mutations: MutationPayload[]
  origin: 'local' | 'remote'
}

/**
 * @hidden
 * @beta */
declare interface DocumentRebaseEvent {
  type: 'rebase'
  document: SanityDocument
  remoteMutations: MutationPayload[]
  localMutations: MutationPayload[]
}

/**
 * @hidden
 * @beta */
declare interface DocumentRemoteMutationEvent {
  type: 'remoteMutation'
  head: SanityDocument
  transactionId: string
  author: string
  timestamp: Date
  effects: {
    apply: unknown
    revert: unknown
  }
}

/**
 * Configuration object for resolving documents based on URL route patterns.
 * Used to define the main document when navigating to specific URLs in
 * Presentation tool's preview iframe.
 *
 * Supports three different resolution strategies:
 *
 * **Simple type-based resolution:**
 * ```ts
 * {
 *   route: '/blog',
 *   type: 'blog'  // Useful for singleton documents
 * }
 * ```
 *
 * **GROQ filter-based resolution:**
 * ```ts
 * {
 *   route: '/blog/:category/:slug',
 *   filter: ({ params }) => `_type == "post" && slug.current == "${params.slug}"`,
 *   params: ({ params }) => ({ category: params.category })
 * }
 * ```
 *
 * **Advanced resolution with custom logic:**
 * ```ts
 * {
 *   route: '/products/:id',
 *   resolve: ({ params }) => ({
 *     filter: `_type == "product" && _id == $id`,
 *     params: { id: params.id }
 *   })
 * }
 * ```
 *
 * @public
 */
export declare type DocumentResolver =
  | {
      route: string | Array<string>
      type: string
      filter?: never
      params?: never
      resolve?: never
    }
  | {
      route: string | Array<string>
      type?: never
      filter: ContextFn<string> | string
      params?: ContextFn<Record<string, string>> | Record<string, string>
      resolve?: never
    }
  | {
      route: string | Array<string>
      type?: never
      filter?: never
      params?: never
      resolve: ContextFn<
        | {
            filter: string
            params?: Record<string, string>
          }
        | undefined
      >
    }

/**
 * Context object passed to functions used in `DocumentResolver` definitions.
 * Contains information about the current URL being matched against route patterns.
 *
 * @example
 * For a route pattern `/blog/:category/:slug` matching URL `https://example.com/blog/tech/hello-world`:
 * ```ts
 * {
 *   origin: 'https://example.com',
 *   params: { category: 'tech', slug: 'hello-world' },
 *   path: '/blog/tech/hello-world'
 * }
 * ```
 *
 * @public
 */
export declare interface DocumentResolverContext {
  /**
   * The origin (protocol + hostname + port) of the matched URL
   */
  origin: string
  /**
   * Extracted route parameters from URL path matching (e.g., `:slug` â†’ `{slug: 'value'}`)
   */
  params: Record<string, string>
  /**
   * The pathname of the matched URL (without query parameters)
   */
  path: string
}

/**
 * Represents a document revision identifier.
 * Can be either a specific revision string
 * or 'lastRevision' to get the most recent revision.
 *
 * @beta
 */
declare type DocumentRevision = string | 'lastRevision'

/**
 * @hidden
 * @beta */
declare interface DocumentStore {
  /**
   * Checks out a document (with its published and draft version) for real-time editing.
   * Note that every call to this function will open a new listener to the server.
   * It's recommended to use the helper functions on `pair` below which will re-use a single connection.
   *
   * @internal
   **/
  checkoutPair: (idPair: IdPair) => Pair
  initialValue: (
    opts: InitialValueOptions,
    context: InitialValueResolverContext,
  ) => Observable<InitialValueMsg>
  listenQuery: (
    query:
      | string
      | {
          fetch: string
          listen: string
        },
    params: QueryParams,
    options: ListenQueryOptions,
  ) => Observable<any>
  resolveTypeForDocument: (id: string, specifiedType?: string) => Observable<string>
  pair: {
    consistencyStatus: (publishedId: string, type: string, version?: string) => Observable<boolean>
    /** @internal */
    documentEvents: (
      publishedId: string,
      type: string,
      version?: string,
    ) => Observable<DocumentVersionEvent>
    /** @internal */
    editOperations: (
      publishedId: string,
      type: string,
      version?: string,
    ) => Observable<OperationsAPI>
    editState: (publishedId: string, type: string, version?: string) => Observable<EditStateFor>
    operationEvents: (
      publishedId: string,
      type: string,
    ) => Observable<OperationSuccess | OperationError>
    validation: (
      validationTargetId: string,
      type: string,
      validatePublishedReferences: boolean,
    ) => Observable<ValidationStatus>
  }
}

/**
 * @hidden
 * @beta */
declare type DocumentValuePermission = 'read' | 'create' | 'update' | 'history' | 'editHistory'

/**
 * Indicates the type of document variant, either `draft`, `version` or `published`.
 * Draft documents are prefixed with `drafts.`.
 * Version documents are prefixed with `versions.<versionName>`
 * The rest are considered published documents.
 * @public
 */
declare type DocumentVariantType = 'draft' | 'version' | 'published'

/**
 * @hidden
 * @beta */
declare interface DocumentVersion {
  consistency$: Observable<boolean>
  remoteSnapshot$: Observable<RemoteSnapshotVersionEvent>
  events: Observable<DocumentVersionEvent>
  patch: (patches: any[]) => MutationPayload[]
  create: (document: Partial<SanityDocument>) => MutationPayload
  createIfNotExists: (document: SanityDocument) => MutationPayload
  createOrReplace: (document: SanityDocument) => MutationPayload
  delete: () => MutationPayload
  mutate: (mutations: MutationPayload[]) => void
  commit: () => void
}

/**
 * @hidden
 * @beta */
declare type DocumentVersionEvent = WithVersion<
  ReconnectEvent | BufferedDocumentEvent | WelcomeEvent
>

/**
 * @hidden
 * @beta */
declare interface EditStateFor {
  id: string
  type: string
  transactionSyncLock: TransactionSyncLockState | null
  draft: SanityDocument | null
  published: SanityDocument | null
  version: SanityDocument | null
  /**
   * Whether live edit is enabled. This may be true for various reasons:
   *
   * - The schema type has live edit enabled.
   * - A version of the document is checked out.
   */
  liveEdit: boolean
  /**
   * Whether the schema type has live edit enabled.
   */
  liveEditSchemaType: boolean
  ready: boolean
  /**
   * When editing a version, the name of the release the document belongs to.
   */
  release: string | undefined
}

declare type GuardedOperation = Operation<any[], 'NOT_READY'>

/**
 * Configuration options for Presentation tool's optional custom preview header component
 *
 * @public
 */
export declare interface HeaderOptions {
  /**
   * React component to render as the preview header, receives PreviewHeaderProps
   */
  component: ComponentType<PreviewHeaderProps>
}

/** @internal */
declare interface IdPair {
  draftId: string
  publishedId: string
  versionId?: string
}

/**
 * @hidden
 * @beta */
declare interface InitialValueErrorMsg {
  type: 'error'
  error: Error
}

/**
 * @hidden
 * @beta */
declare interface InitialValueLoadingMsg {
  type: 'loading'
}

/**
 * @hidden
 * @beta */
declare type InitialValueMsg =
  | InitialValueLoadingMsg
  | InitialValueSuccessMsg
  | InitialValueErrorMsg

/**
 * @hidden
 * @beta */
declare interface InitialValueOptions {
  documentId: string
  documentType: string
  templateName?: string
  templateParams?: Record<string, any>
}

/**
 * @hidden
 * @beta */
declare interface InitialValueSuccessMsg {
  type: 'success'
  value: SanityDocumentLike | null
}

declare type Input = Omit<SetPreviewSearchParamEvent, 'type'>

/**
 * parameters for the changes inspector
 * @public
 */
export declare interface InspectorTab {
  changesInspectorTab?: 'history' | 'review'
}

/**
 * @hidden
 * @beta */
declare interface ListenQueryOptions {
  tag?: string
  apiVersion?: string
  perspective?: ClientPerspective
  throttleTime?: number
  transitions?: ('update' | 'appear' | 'disappear')[]
}

/** @public */
declare type MapDocument = (document: SanityDocumentLike) => SanityDocumentLike

/**
 * @hidden
 * @beta */
declare interface MutationPayload {
  create?: any
  createIfNotExists?: any
  createOrReplace?: any
  delete?: any
  patch?: any
}

/**
 * Configuration options for Presentation tool's optional navigator component
 * The navigator appears as a resizable sidebar panel
 *
 * @public
 */
export declare interface NavigatorOptions {
  /**
   * Minimum width of the navigator panel in pixels
   */
  minWidth?: number
  /**
   * Maximum width of the navigator panel in pixels
   */
  maxWidth?: number
  /**
   * React component to render in the navigator panel
   */
  component: ComponentType
}

/** @internal */
declare interface Operation<ExtraArgs extends any[] = [], ErrorStrings extends string = string> {
  disabled: false | ErrorStrings | 'NOT_READY'
  execute(...extra: ExtraArgs): void
}

/**
 * @hidden
 * @beta */
declare interface OperationError {
  type: 'error'
  /** @internal */
  op: keyof OperationsAPI
  id: string
  error: Error
}

/** @internal */
declare interface OperationsAPI {
  commit: Operation | GuardedOperation
  delete: Operation<[versions?: string[]], 'NOTHING_TO_DELETE' | 'NOT_READY'>
  del: Operation<[versions?: string[]], 'NOTHING_TO_DELETE'> | GuardedOperation
  publish:
    | Operation<[], 'LIVE_EDIT_ENABLED' | 'ALREADY_PUBLISHED' | 'NO_CHANGES'>
    | GuardedOperation
  patch: Operation<[patches: Patch[], initialDocument?: Record<string, any>]> | GuardedOperation
  discardChanges: Operation<[], 'NO_CHANGES' | 'NOT_PUBLISHED'> | GuardedOperation
  unpublish: Operation<[], 'LIVE_EDIT_ENABLED' | 'NOT_PUBLISHED'> | GuardedOperation
  duplicate:
    | Operation<
        [
          documentId: string,
          options?: {
            mapDocument?: MapDocument
          },
        ],
        'NOTHING_TO_DUPLICATE'
      >
    | GuardedOperation
  restore: Operation<[revision: DocumentRevision]> | GuardedOperation
}

/**
 * @hidden
 * @beta */
declare interface OperationSuccess {
  type: 'success'
  /** @internal */
  op: keyof OperationsAPI
  id: string
}

/**
 * @hidden
 * @beta */
declare type Pair = {
  /** @internal */
  transactionsPendingEvents$: Observable<PendingMutationsEvent>
  published: DocumentVersion
  draft: DocumentVersion
  version?: DocumentVersion
}

declare type Patch = any

/** @internal */
declare interface PendingMutationsEvent {
  type: 'pending'
  phase: 'begin' | 'end'
}

/**
 * @hidden
 * @beta */
declare interface PermissionCheckResult {
  granted: boolean
  reason: string
}

declare const presentationMachine: StateMachine<
  Context,
  | {
      type: 'toggle visual editing overlays'
      enabled: boolean
    }
  | {
      type: 'iframe loaded'
    }
  | {
      type: 'iframe refresh'
    }
  | {
      type: 'iframe reload'
    },
  {},
  never,
  never,
  never,
  never,
  | 'error'
  | 'loading'
  | {
      loaded: 'idle' | 'refreshing' | 'reloading'
    },
  'error' | 'busy',
  NonReducibleUnknown,
  NonReducibleUnknown,
  EventObject,
  MetaObject,
  {
    id: 'Presentation Tool'
    states: {
      readonly error: {}
      readonly loading: {}
      readonly loaded: {
        states: {
          readonly idle: {}
          readonly refreshing: {}
          readonly reloading: {}
        }
      }
    }
  }
>

declare type PresentationMachineRef = ActorRefFrom<typeof presentationMachine>

/** @public */
export declare type PresentationNavigateContextValue = (
  preview: string | undefined,
  document?: {
    type: string
    id: string
  },
) => void

/**
 * All possible parameters that can be used to describe the state of the
 * Presentation tool, stored in the pathname and as search parameters of the URL
 * @public
 */
export declare interface PresentationParams extends PresentationStateParams, CombinedSearchParams {}

/** @public */
export declare type PresentationPerspective = Exclude<ClientPerspective, 'raw'>

/**
 * Configuration options for the Presentation tool.
 * @public
 */
export declare interface PresentationPluginOptions {
  devMode?: boolean | (() => boolean)
  icon?: ComponentType
  name?: string
  title?: string
  allowOrigins?: PreviewUrlAllowOption
  previewUrl: PreviewUrlOption
  /**
   * @deprecated use `resolve.locations` instead
   */
  locate?: DocumentLocationResolver
  resolve?: {
    mainDocuments?: DocumentResolver[]
    locations?: DocumentLocationResolvers | DocumentLocationResolver
  }
  components?: {
    unstable_header?: HeaderOptions
    unstable_navigator?: NavigatorOptions
  }
  /**
   * @deprecated this feature flag is no longer needed
   */
  unstable_showUnsafeShareUrl?: boolean
}

/**
 * Presentation specific URL search parameters, they should persist when
 * navigating between the document pane and document list pane
 * @public
 */
export declare interface PresentationSearchParams {
  preview?: string
  perspective?: string
  viewport?: string
}

/**
 * Presentation specific state that is stored in the pathname section of the URL
 * @public
 */
export declare interface PresentationStateParams {
  type?: string
  id?: string
  path?: string
}

/** @public */
export declare const presentationTool: any

/** @public */
export declare type PresentationViewport = 'desktop' | 'mobile'

/** @public */
export declare interface PreviewHeaderProps extends PreviewProps {
  iframeRef: RefObject<HTMLIFrameElement | null>
  renderDefault: (props: PreviewHeaderProps) => React.JSX.Element
}

/** @public */
export declare interface PreviewProps {
  canSharePreviewAccess: boolean
  canToggleSharePreviewAccess: boolean
  canUseSharedPreviewAccess: boolean
  header?: HeaderOptions
  initialUrl: URL
  loadersConnection: ConnectionStatus
  navigatorEnabled: boolean
  onPathChange: (nextPath: string) => void
  onRefresh: (fallback: () => void) => void
  openPopup: (url: string) => void
  overlaysConnection: ConnectionStatus
  presentationRef: PresentationMachineRef
  perspective: PresentationPerspective
  previewUrl?: string
  setViewport: (mode: 'desktop' | 'mobile') => void
  targetOrigin: string
  toggleNavigator?: () => void
  toggleOverlay: () => void
  viewport: PresentationViewport
  vercelProtectionBypass: string | null
  previewUrlRef: PreviewUrlRef
}

/** @public */
declare type PreviewUrlAllowOption =
  | string
  | string[]
  | ((context: PreviewUrlAllowOptionContext) => string | string[] | Promise<string | string[]>)

/** @public */
declare interface PreviewUrlAllowOptionContext {
  client: SanityClient
  /**
   * Equivalent to `location.origin`
   */
  origin: string
  /**
   * The initial URL of the preview
   */
  initialUrl: URL
}

/** @public */
declare type PreviewUrlInitialOption =
  | string
  | ((context: PreviewUrlInitialOptionContext) => string | Promise<string>)

/** @public */
declare interface PreviewUrlInitialOptionContext {
  client: SanityClient
  /**
   * Equivalent to `location.origin`
   */
  origin: string
}

declare const previewUrlMachine: StateMachine<
  Context_2,
  SetPreviewSearchParamEvent,
  {
    [x: string]:
      | ActorRefFromLogic<
          PromiseActorLogic<
            URL,
            {
              initialUrl: URL
              previewSearchParam: string | null | undefined
              allowOrigins: URLPattern[]
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          ObservableActorLogic<PermissionCheckResult, CheckPermissionInput, EventObject>
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            URL,
            {
              previewSearchParam: string | null
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            URLPattern[],
            {
              initialUrl: URL
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            false | PreviewUrlPreviewMode,
            {
              targetOrigin: string
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            {
              secret: string
              expiresAt: Date
            },
            NonReducibleUnknown,
            EventObject
          >
        >
      | ActorRefFromLogic<PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>>
      | ActorRefFromLogic<PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>>
      | undefined
  },
  | {
      src: 'resolve url from preview search param'
      logic: PromiseActorLogic<
        URL,
        {
          initialUrl: URL
          previewSearchParam: string | null | undefined
          allowOrigins: URLPattern[]
        },
        EventObject
      >
      id: string | undefined
    }
  | {
      src: 'check permission'
      logic: ObservableActorLogic<PermissionCheckResult, CheckPermissionInput, EventObject>
      id: string | undefined
    }
  | {
      src: 'resolve initial url'
      logic: PromiseActorLogic<
        URL,
        {
          previewSearchParam: string | null
        },
        EventObject
      >
      id: string | undefined
    }
  | {
      src: 'resolve allow patterns'
      logic: PromiseActorLogic<
        URLPattern[],
        {
          initialUrl: URL
        },
        EventObject
      >
      id: string | undefined
    }
  | {
      src: 'resolve preview mode'
      logic: PromiseActorLogic<
        false | PreviewUrlPreviewMode,
        {
          targetOrigin: string
        },
        EventObject
      >
      id: string | undefined
    }
  | {
      src: 'create preview secret'
      logic: PromiseActorLogic<
        {
          secret: string
          expiresAt: Date
        },
        NonReducibleUnknown,
        EventObject
      >
      id: string | undefined
    }
  | {
      src: 'read shared preview secret'
      logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
      id: string | undefined
    }
  | {
      src: 'resolve preview mode url'
      logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
      id: string | undefined
    },
  | {
      type: 'notify preview will likely fail'
      params: NonReducibleUnknown
    }
  | {
      type: 'assign preview search param'
      params: {
        previewSearchParam: string | null
      }
    }
  | {
      type: 'assign error'
      params: {
        message: string
        error: unknown
      }
    },
  | {
      type: 'has checked permissions'
      params: unknown
    }
  | {
      type: 'search param has new origin'
      params: unknown
    }
  | {
      type: 'can create preview secret'
      params: unknown
    }
  | {
      type: 'has preview mode with created secret'
      params: false | PreviewUrlPreviewMode
    }
  | {
      type: 'has preview mode with share access'
      params: false | PreviewUrlPreviewMode
    }
  | {
      type: 'has preview mode without permissions'
      params: false | PreviewUrlPreviewMode
    },
  'expiredSecret',
  | 'error'
  | 'success'
  | 'checkingPermissions'
  | 'resolvingInitialUrl'
  | 'resolvingAllowPatterns'
  | 'resolvingUrlFromPreviewSearchParam'
  | 'resolvingPreviewMode'
  | {
      previewMode:
        | 'error'
        | 'success'
        | 'createPreviewSecret'
        | 'resolvePreviewUrl'
        | 'readShareAccess'
    },
  'error' | 'busy',
  Input,
  NonReducibleUnknown,
  EventObject,
  MetaObject,
  {
    id: 'Preview URL'
    states: {
      readonly checkingPermissions: {}
      readonly resolvingInitialUrl: {}
      readonly error: {}
      readonly resolvingAllowPatterns: {}
      readonly resolvingUrlFromPreviewSearchParam: {
        id: 'loop'
      }
      readonly resolvingPreviewMode: {}
      readonly success: {}
      readonly previewMode: {
        states: {
          readonly createPreviewSecret: {}
          readonly readShareAccess: {}
          readonly resolvePreviewUrl: {}
          readonly error: {}
          readonly success: {}
        }
      }
    }
  }
>

/** @public */
export declare type PreviewUrlOption =
  | string
  | DeprecatedPreviewUrlResolver
  | PreviewUrlResolverOptions

/** @public */
declare interface PreviewUrlPreviewMode {
  /**
   * The route that enables Preview Mode
   * @example '/api/preview'
   * @example '/api/draft-mode/enable'
   */
  enable: string
  /**
   * Allow sharing access to a preview with others.
   * This is enabled/disabled in the Presentation Tool. It's initially disabled, and can be enabled by someone who has access to creating draft documents in the Studio.
   * Custom roles can limit access to `_id in path("drafts.**") && _type == "sanity.previewUrlSecret"`.
   * This will create a secret that is valid until sharing is disabled. Turning sharing off and on again will create a new secret and can be used to remove access for folks that got the link in an email but should no longer have access.
   * Share URLs to previews will append this secret and give access to anyone who is given the URL, they don't need to be logged into the Studio or to Vercel.
   */
  shareAccess?: boolean
  /**
   * The route that reports if Preview Mode is enabled or not, useful for debugging
   * @example '/api/check-preview'
   * @deprecated - this API is not yet implemented
   */
  check?: string
  /**
   * The route that disables Preview Mode, useful for debugging
   * @example '/api/disable-preview'
   * @deprecated - this API is not yet implemented
   */
  disable?: string
}

/** @public */
declare type PreviewUrlPreviewModeOption =
  | PreviewUrlPreviewMode
  | ((
      context: PreviewUrlPreviewModeOptionContext,
    ) => false | PreviewUrlPreviewMode | Promise<false | PreviewUrlPreviewMode>)

/** @public */
declare interface PreviewUrlPreviewModeOptionContext {
  client: SanityClient
  /**
   * Equivalent to `location.origin`
   */
  origin: string
  /**
   * The origin on the URL that will be used in the preview iframe
   */
  targetOrigin: string
}

declare type PreviewUrlRef = ActorRefFrom<typeof previewUrlMachine>

export {PreviewUrlResolver}

/**
 * @public
 */
export declare interface PreviewUrlResolverOptions {
  /**
   * The default preview URL, used when the URL to use is not yet known, or there's no `&preview=...` search param in the studio URL.
   * @example '/en/preview?q=shoes'
   * @example 'https://example.com'
   * @defaultValue `location.origin`
   */
  initial?: PreviewUrlInitialOption
  previewMode?: PreviewUrlPreviewModeOption
  /**
   * @defaultValue `location.origin`
   * @deprecated - use `initial` instead
   */
  origin?: string
  /**
   * @defaultValue '/'
   * @deprecated - use `initial` instead
   */
  preview?: string
  /**
   * @deprecated - use `previewMode` instead
   */
  draftMode?: {
    /**
     * @deprecated - use `previewMode.enable` instead
     */
    enable: string
    /**
     * @deprecated - use `previewMode.shareAccess` instead
     */
    shareAccess?: boolean
    /**
     * @deprecated - use `previewMode.check` instead
     */
    check?: string
    /**
     * @deprecated - use `previewMode.disable` instead
     */
    disable?: string
  }
}

/**
 * @hidden
 * @beta */
declare type QueryParams = Record<string, string | number | boolean | string[]>

/**
 * @hidden
 * @beta */
declare interface ReconnectEvent {
  type: 'reconnect'
}

/**
 * @hidden
 * @beta */
declare type RemoteSnapshotEvent = DocumentRemoteMutationEvent | SnapshotEvent

/**
 * @hidden
 * @beta */
declare type RemoteSnapshotVersionEvent = WithVersion<RemoteSnapshotEvent>

/** @internal */
declare interface ResolvePreviewModeUrlInput {
  previewUrlSecret: string
  resolvedPreviewMode: PreviewUrlPreviewMode
  initialUrl: URL
}

export {Serializable}

export {SerializableArray}

export {SerializableObject}

export {SerializablePrimitive}

declare type SetPreviewSearchParamEvent = {
  type: 'set preview search param'
  previewSearchParam: string | null
}

/**
 * @hidden
 * @beta */
declare interface SnapshotEvent {
  type: 'snapshot'
  document: SanityDocument
}

/**
 * Document Pane specific URL search parameters, they should not persist when
 * navigating between the document pane and document list pane
 * @public
 */
export declare interface StructureDocumentPaneParams extends InspectorTab {
  inspect?: string
  parentRefPath?: string
  path?: string
  rev?: string
  since?: string
  template?: string
  templateParams?: string
  version?: string
  view?: string
  pathKey?: string
  instruction?: string
  comment?: string
  scheduledDraft?: string
}

declare interface TransactionSyncLockState {
  enabled: boolean
}

/** @public */
export declare function usePresentationNavigate(): PresentationNavigateContextValue

/** @public */
export declare function usePresentationParams(throwOnMissingContext?: true): PresentationParams

/** @public */
export declare function usePresentationParams(
  throwOnMissingContext: false,
): PresentationParams | null

/** @public */
export declare const useSharedState: (key: string, value: Serializable) => undefined

/**
 * @hidden
 * @beta */
declare interface ValidationStatus {
  isValidating: boolean
  validation: ValidationMarker[]
  revision?: string
}

/** @beta */
declare interface WelcomeEvent {
  type: 'welcome'
  listenerName: string
}

/**
 * @hidden
 * @beta */
declare type WithVersion<T> = T & {
  version: DocumentVariantType
}

export {}
