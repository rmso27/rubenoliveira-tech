import path, { dirname, join } from "node:path";
import { debounce, once, mean } from "lodash-es";
import { promiseWithResolvers } from "./promiseWithResolvers.js";
import { defineTrace } from "@sanity/telemetry";
import { formatSchemaValidation } from "./formatSchemaValidation.js";
import { writeFile } from "node:fs/promises";
import { fileURLToPath } from "node:url";
import { Worker } from "node:worker_threads";
import readPkgUp from "read-pkg-up";
import chokidar from "chokidar";
const SchemaExtractedTrace = defineTrace({
  name: "Schema Extracted",
  version: 0,
  description: "Trace emitted when extracting schema"
}), SchemaExtractionWatchModeTrace = defineTrace({
  name: "Schema Extraction Watch Mode Started",
  version: 0,
  description: "Trace emitted when schema extraction watch mode is run"
}), DEFAULT_WATCH_PATTERNS = ["sanity.config.{js,jsx,ts,tsx,mjs}", "schema*/**/*.{js,jsx,ts,tsx,mjs}"], IGNORED_PATTERNS = ["**/node_modules/**", "**/.git/**", "**/dist/**", "**/lib/**", "**/.sanity/**"];
function createExtractionRunner(onExtract) {
  const state = {
    isExtracting: !1,
    pendingExtraction: !1
  };
  async function runExtraction() {
    if (state.isExtracting) {
      state.pendingExtraction = !0;
      return;
    }
    state.isExtracting = !0, state.pendingExtraction = !1;
    try {
      await onExtract();
    } finally {
      state.isExtracting = !1, state.pendingExtraction && (state.pendingExtraction = !1, await runExtraction());
    }
  }
  return {
    state,
    runExtraction
  };
}
async function createSchemaWatcher(options) {
  const {
    workDir,
    patterns,
    debounceMs = 1e3,
    onExtract,
    output
  } = options, {
    runExtraction
  } = createExtractionRunner(onExtract), debouncedExtract = debounce(() => {
    runExtraction();
  }, debounceMs), absolutePatterns = patterns.map((pattern) => path.isAbsolute(pattern) ? pattern : path.join(workDir, pattern)), watcher = chokidar.watch(absolutePatterns, {
    ignoreInitial: !0,
    ignored: IGNORED_PATTERNS,
    cwd: workDir
  });
  return watcher.on("all", (event, filePath) => {
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString(), relativePath = path.isAbsolute(filePath) ? path.relative(workDir, filePath) : filePath;
    output.print(`[${timestamp}] ${event}: ${relativePath}`), debouncedExtract();
  }), watcher.on("error", (err) => {
    output.error(`Watcher error: ${err instanceof Error ? err.message : String(err)}`);
  }), watcher;
}
const __dirname$1 = dirname(fileURLToPath(import.meta.url));
class SchemaExtractionError extends Error {
  constructor(message, validation) {
    super(message), this.name = "SchemaExtractionError", this.validation = validation;
  }
}
async function extractSchemaToFile(options) {
  const {
    workDir,
    outputPath,
    workspaceName,
    enforceRequiredFields = !1,
    format = "groq-type-nodes"
  } = options, rootPkgPath = readPkgUp.sync({
    cwd: __dirname$1
  })?.path;
  if (!rootPkgPath)
    throw new Error("Could not find root directory for `sanity` package");
  const workerPath = join(dirname(rootPkgPath), "lib", "_internal", "cli", "threads", "extractSchema.cjs"), worker = new Worker(workerPath, {
    workerData: {
      workDir,
      workspaceName,
      enforceRequiredFields,
      format
    },
    env: process.env
  }), message = await new Promise((resolve, reject) => {
    worker.addListener("message", resolve), worker.addListener("error", reject);
  });
  if (message.type === "error")
    throw new SchemaExtractionError(message.error, message.validation);
  return await writeFile(outputPath, `${JSON.stringify(message.schema, null, 2)}
`), message.schema;
}
async function startSchemaWatcher(options) {
  const {
    workDir,
    outputPath,
    output,
    workspaceName,
    enforceRequiredFields = !1,
    format = "groq-type-nodes",
    patterns = DEFAULT_WATCH_PATTERNS,
    onExtraction
  } = options, runExtraction = async (spinnerText, successText) => {
    const spinner = output.spinner({}).start(spinnerText), startTime = Date.now();
    try {
      const schema = await extractSchemaToFile({
        workDir,
        outputPath,
        workspaceName,
        enforceRequiredFields,
        format
      });
      return onExtraction?.({
        success: !0,
        schema,
        duration: Date.now() - startTime
      }), spinner.succeed(successText), !0;
    } catch (err) {
      return onExtraction?.({
        success: !1,
        duration: Date.now() - startTime
      }), spinner.fail(`Extraction failed: ${err instanceof Error ? err.message : String(err)}`), err instanceof SchemaExtractionError && err.validation && err.validation.length > 0 && (output.print(""), output.print(formatSchemaValidation(err.validation))), !1;
    }
  };
  await runExtraction("Extracting schema...", `Extracted schema to ${outputPath}`);
  const watcher = await createSchemaWatcher({
    workDir,
    patterns,
    onExtract: async () => {
      await runExtraction("Extracting schema...", `Extracted schema to ${outputPath}`);
    },
    output
  });
  return {
    stop: async () => {
      await watcher.close();
    },
    watcher
  };
}
async function extractAction(args, context) {
  return args.extOptions.watch ? runWatchMode(args, context) : runSingleExtraction(args, context);
}
function getExtractOptions(flags, config, workDir) {
  const schemaExtraction = config?.schemaExtraction;
  return {
    workspace: flags.workspace ?? schemaExtraction?.workspace,
    format: flags.format ?? "groq-type-nodes",
    enforceRequiredFields: flags["enforce-required-fields"] ?? schemaExtraction?.enforceRequiredFields ?? !1,
    outputPath: flags.path ?? schemaExtraction?.path ?? join(workDir, "schema.json"),
    watchPatterns: flags["watch-patterns"] ? Array.isArray(flags["watch-patterns"]) ? flags["watch-patterns"] : [flags["watch-patterns"]] : schemaExtraction?.watchPatterns ?? []
  };
}
async function runSingleExtraction(args, context) {
  const flags = args.extOptions, {
    workDir,
    output,
    telemetry,
    cliConfig
  } = context, {
    format,
    enforceRequiredFields,
    outputPath,
    workspace: workspaceName
  } = getExtractOptions(flags, cliConfig, workDir), spinner = output.spinner({}).start(enforceRequiredFields ? "Extracting schema, with enforced required fields" : "Extracting schema"), trace = telemetry.trace(SchemaExtractedTrace);
  trace.start();
  try {
    const schema = await extractSchemaToFile({
      workDir,
      outputPath,
      workspaceName,
      enforceRequiredFields,
      format
    });
    trace.log({
      schemaAllTypesCount: schema.length,
      schemaDocumentTypesCount: schema.filter((type) => type.type === "document").length,
      schemaTypesCount: schema.filter((type) => type.type === "type").length,
      enforceRequiredFields,
      schemaFormat: format
    }), trace.complete(), spinner.succeed(enforceRequiredFields ? `Extracted schema to ${outputPath} with enforced required fields` : `Extracted schema to ${outputPath}`);
  } catch (err) {
    throw trace.error(err), spinner.fail(enforceRequiredFields ? "Failed to extract schema, with enforced required fields" : "Failed to extract schema"), err instanceof SchemaExtractionError && err.validation && err.validation.length > 0 && (output.print(""), output.print(formatSchemaValidation(err.validation))), err;
  }
}
async function runWatchMode(args, context) {
  const flags = args.extOptions, startTime = Date.now(), stats = {
    successfulDurations: [],
    failedCount: 0
  }, {
    workDir,
    output,
    telemetry,
    cliConfig
  } = context, options = getExtractOptions(flags, cliConfig, workDir), {
    format,
    enforceRequiredFields,
    outputPath,
    watchPatterns: additionalPatterns,
    workspace: workspaceName
  } = options, watchPatterns = [...DEFAULT_WATCH_PATTERNS, ...additionalPatterns], trace = telemetry.trace(SchemaExtractionWatchModeTrace);
  trace.start(), output.print("Schema extraction watch mode"), output.print(""), output.print("Watching for changes in:");
  for (const pattern of watchPatterns)
    output.print(`  - ${pattern}`);
  output.print(""), output.print("Running initial extraction...");
  const {
    stop
  } = await startSchemaWatcher({
    workDir,
    outputPath,
    output,
    workspaceName,
    enforceRequiredFields,
    format,
    patterns: watchPatterns,
    onExtraction: ({
      success,
      duration
    }) => {
      success ? stats.successfulDurations.push(duration) : stats.failedCount++;
    }
  });
  trace.log({
    step: "started",
    enforceRequiredFields,
    schemaFormat: format
  }), output.print(""), output.print("Watching for changes... (Ctrl+C to stop)");
  const {
    resolve,
    promise
  } = promiseWithResolvers(), cleanup = once(() => {
    trace.log({
      step: "stopped",
      watcherDuration: Date.now() - startTime,
      averageExtractionDuration: mean(stats.successfulDurations),
      extractionSuccessfulCount: stats.successfulDurations.length,
      extractionFailedCount: stats.failedCount
    }), trace.complete(), output.print(""), output.print("Stopping watch mode..."), stop(), resolve();
  });
  process.on("SIGINT", cleanup), process.on("SIGTERM", cleanup), await promise;
}
export {
  extractAction as default,
  getExtractOptions
};
//# sourceMappingURL=extractAction.js.map
