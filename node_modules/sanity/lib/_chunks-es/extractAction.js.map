{"version":3,"file":"extractAction.js","sources":["../../src/_internal/cli/actions/schema/extractSchema.telemetry.ts","../../src/_internal/cli/actions/schema/watchExtract.ts","../../src/_internal/cli/actions/schema/schemaExtractorApi.ts","../../src/_internal/cli/actions/schema/extractAction.ts"],"sourcesContent":["import {defineTrace} from '@sanity/telemetry'\n\ninterface SchemaExtractedTraceAttrubutes {\n  schemaAllTypesCount: number\n  schemaDocumentTypesCount: number\n  schemaTypesCount: number\n\n  enforceRequiredFields: boolean\n  schemaFormat: string\n}\n\ntype SchemaExtractionWatchModeAttributes =\n  | {\n      step: 'started'\n      enforceRequiredFields: boolean\n      schemaFormat: string\n    }\n  | {\n      step: 'stopped'\n      extractionSuccessfulCount: number\n      extractionFailedCount: number\n      averageExtractionDuration: number\n      watcherDuration: number\n    }\n\nexport const SchemaExtractedTrace = defineTrace<SchemaExtractedTraceAttrubutes>({\n  name: 'Schema Extracted',\n  version: 0,\n  description: 'Trace emitted when extracting schema',\n})\n\nexport const SchemaExtractionWatchModeTrace = defineTrace<SchemaExtractionWatchModeAttributes>({\n  name: 'Schema Extraction Watch Mode Started',\n  version: 0,\n  description: 'Trace emitted when schema extraction watch mode is run',\n})\n","import path from 'node:path'\n\nimport {type CliOutputter} from '@sanity/cli'\nimport chokidar, {type FSWatcher} from 'chokidar'\nimport {debounce} from 'lodash-es'\n\n/** Default glob patterns to watch for schema changes */\nexport const DEFAULT_WATCH_PATTERNS = [\n  'sanity.config.{js,jsx,ts,tsx,mjs}',\n  'schema*/**/*.{js,jsx,ts,tsx,mjs}',\n]\n\n/** Default patterns to ignore when watching */\nconst IGNORED_PATTERNS = [\n  '**/node_modules/**',\n  '**/.git/**',\n  '**/dist/**',\n  '**/lib/**',\n  '**/.sanity/**',\n]\n\ninterface WatchExtractOptions {\n  workDir: string\n  patterns: string[]\n  debounceMs?: number\n  onExtract: () => Promise<void>\n  output: CliOutputter\n}\n\n/** State for tracking extraction status */\nexport interface WatchState {\n  isExtracting: boolean\n  pendingExtraction: boolean\n}\n\n/** Return type for createExtractionRunner */\nexport interface ExtractionRunner {\n  state: WatchState\n  runExtraction: () => Promise<void>\n}\n\n/**\n * Creates an extraction runner with concurrency control.\n * If extraction is already running, queues one more extraction to run after completion.\n * Multiple queued requests are coalesced into a single pending extraction.\n */\nexport function createExtractionRunner(onExtract: () => Promise<void>): ExtractionRunner {\n  const state: WatchState = {\n    isExtracting: false,\n    pendingExtraction: false,\n  }\n\n  async function runExtraction(): Promise<void> {\n    if (state.isExtracting) {\n      state.pendingExtraction = true\n      return\n    }\n\n    state.isExtracting = true\n    state.pendingExtraction = false\n\n    try {\n      await onExtract()\n    } finally {\n      state.isExtracting = false\n\n      // If a change came in during extraction, run again\n      if (state.pendingExtraction) {\n        state.pendingExtraction = false\n        await runExtraction()\n      }\n    }\n  }\n\n  return {state, runExtraction}\n}\n\n/**\n * Creates a file watcher that triggers schema extraction on changes.\n * Implements debouncing and concurrency control to prevent multiple extractions.\n */\nexport async function createSchemaWatcher(options: WatchExtractOptions): Promise<FSWatcher> {\n  const {workDir, patterns, debounceMs = 1000, onExtract, output} = options\n\n  const {runExtraction} = createExtractionRunner(onExtract)\n\n  // Debounced extraction trigger\n  const debouncedExtract = debounce(() => {\n    void runExtraction()\n  }, debounceMs)\n\n  // Build absolute patterns for watching\n  const absolutePatterns = patterns.map((pattern) =>\n    path.isAbsolute(pattern) ? pattern : path.join(workDir, pattern),\n  )\n\n  const watcher = chokidar.watch(absolutePatterns, {\n    ignoreInitial: true,\n    ignored: IGNORED_PATTERNS,\n    cwd: workDir,\n  })\n\n  watcher.on('all', (event, filePath) => {\n    const timestamp = new Date().toLocaleTimeString()\n    const relativePath = path.isAbsolute(filePath) ? path.relative(workDir, filePath) : filePath\n    output.print(`[${timestamp}] ${event}: ${relativePath}`)\n    debouncedExtract()\n  })\n\n  watcher.on('error', (err) => {\n    output.error(`Watcher error: ${err instanceof Error ? err.message : String(err)}`)\n  })\n\n  return watcher\n}\n","import {writeFile} from 'node:fs/promises'\nimport {dirname, join} from 'node:path'\nimport {fileURLToPath} from 'node:url'\nimport {Worker} from 'node:worker_threads'\n\nimport {type CliOutputter} from '@sanity/cli'\nimport {type SchemaValidationProblemGroup} from '@sanity/types'\nimport {type FSWatcher} from 'chokidar'\nimport {type SchemaType} from 'groq-js'\nimport readPkgUp from 'read-pkg-up'\n\nimport {\n  type ExtractSchemaWorkerData,\n  type ExtractSchemaWorkerMessage,\n} from '../../threads/extractSchema'\nimport {formatSchemaValidation} from './formatSchemaValidation'\nimport {createSchemaWatcher, DEFAULT_WATCH_PATTERNS} from './watchExtract'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\n\n/** Error thrown when schema extraction fails, includes validation details if available */\nexport class SchemaExtractionError extends Error {\n  validation?: SchemaValidationProblemGroup[]\n\n  constructor(message: string, validation?: SchemaValidationProblemGroup[]) {\n    super(message)\n    this.name = 'SchemaExtractionError'\n    this.validation = validation\n  }\n}\n\n/** Options for extracting schema to a file */\nexport interface ExtractSchemaOptions {\n  workDir: string\n  outputPath: string\n  workspaceName?: string\n  enforceRequiredFields?: boolean\n  format?: string\n}\n\ninterface OnExtractionCallbackData {\n  success: boolean\n  schema?: SchemaType\n  duration: number\n}\n\n/**\n * Extracts schema to a file. Runs in a worker thread for isolation. Returns the extracted schema\n * after the extraction has completed and the file has been written to the file.\n *\n * Throws SchemaExtractionError with validation details if extraction fails.\n */\nexport async function extractSchemaToFile(options: ExtractSchemaOptions) {\n  const {\n    workDir,\n    outputPath,\n    workspaceName,\n    enforceRequiredFields = false,\n    format = 'groq-type-nodes',\n  } = options\n\n  const rootPkgPath = readPkgUp.sync({cwd: __dirname})?.path\n  if (!rootPkgPath) {\n    throw new Error('Could not find root directory for `sanity` package')\n  }\n\n  const workerPath = join(\n    dirname(rootPkgPath),\n    'lib',\n    '_internal',\n    'cli',\n    'threads',\n    'extractSchema.cjs',\n  )\n\n  const worker = new Worker(workerPath, {\n    workerData: {\n      workDir,\n      workspaceName,\n      enforceRequiredFields,\n      format,\n    } satisfies ExtractSchemaWorkerData,\n    env: process.env,\n  })\n\n  const message = await new Promise<ExtractSchemaWorkerMessage>((resolve, reject) => {\n    worker.addListener('message', resolve)\n    worker.addListener('error', reject)\n  })\n\n  if (message.type === 'error') {\n    throw new SchemaExtractionError(message.error, message.validation)\n  }\n\n  await writeFile(outputPath, `${JSON.stringify(message.schema, null, 2)}\\n`)\n\n  return message.schema\n}\n\n/** Options for starting a schema watcher */\nexport interface SchemaWatcherOptions {\n  workDir: string\n  outputPath: string\n  output: CliOutputter\n  workspaceName?: string\n  enforceRequiredFields?: boolean\n  format?: string\n  patterns?: string[]\n  debounceMs?: number\n\n  /** Optional callback function for listening in on the schema extraction */\n  onExtraction?: (result: OnExtractionCallbackData) => void\n}\n\n/** Result from starting a schema watcher */\nexport interface SchemaWatcherResult {\n  /** Call to stop the watcher */\n  stop: () => Promise<void>\n  /** The underlying FSWatcher instance */\n  watcher: FSWatcher\n}\n\n/**\n * Starts a schema watcher that extracts schema on file changes.\n * Runs an initial extraction before starting to watch.\n * Returns a cleanup function to stop the watcher.\n */\nexport async function startSchemaWatcher(\n  options: SchemaWatcherOptions,\n): Promise<SchemaWatcherResult> {\n  const {\n    workDir,\n    outputPath,\n    output,\n    workspaceName,\n    enforceRequiredFields = false,\n    format = 'groq-type-nodes',\n    patterns = DEFAULT_WATCH_PATTERNS,\n    onExtraction,\n  } = options\n\n  // Helper to run extraction with spinner and error display\n  const runExtraction = async (spinnerText: string, successText: string): Promise<boolean> => {\n    const spinner = output.spinner({}).start(spinnerText)\n    const startTime = Date.now()\n\n    try {\n      const schema = await extractSchemaToFile({\n        workDir,\n        outputPath,\n        workspaceName,\n        enforceRequiredFields,\n        format,\n      })\n\n      onExtraction?.({success: true, schema, duration: Date.now() - startTime})\n      spinner.succeed(successText)\n      return true\n    } catch (err) {\n      onExtraction?.({success: false, duration: Date.now() - startTime})\n      spinner.fail(`Extraction failed: ${err instanceof Error ? err.message : String(err)}`)\n      if (err instanceof SchemaExtractionError && err.validation && err.validation.length > 0) {\n        output.print('')\n        output.print(formatSchemaValidation(err.validation))\n      }\n      return false\n    }\n  }\n\n  // Run initial extraction\n  await runExtraction('Extracting schema...', `Extracted schema to ${outputPath}`)\n\n  // Create extraction callback for watch mode\n  const onExtract = async () => {\n    await runExtraction('Extracting schema...', `Extracted schema to ${outputPath}`)\n  }\n\n  // Start watcher\n  const watcher = await createSchemaWatcher({\n    workDir,\n    patterns,\n    onExtract,\n    output,\n  })\n\n  const stop = async () => {\n    await watcher.close()\n  }\n\n  return {stop, watcher}\n}\n\nexport {DEFAULT_WATCH_PATTERNS}\n","import {join} from 'node:path'\n\nimport {type CliCommandArguments, type CliCommandContext} from '@sanity/cli'\nimport {mean, once} from 'lodash-es'\n\nimport {promiseWithResolvers} from '../../util/promiseWithResolvers'\nimport {SchemaExtractedTrace, SchemaExtractionWatchModeTrace} from './extractSchema.telemetry'\nimport {formatSchemaValidation} from './formatSchemaValidation'\nimport {\n  DEFAULT_WATCH_PATTERNS,\n  extractSchemaToFile,\n  SchemaExtractionError,\n  startSchemaWatcher,\n} from './schemaExtractorApi'\n\nexport interface ExtractFlags {\n  'workspace'?: string\n  'path'?: string\n  'enforce-required-fields'?: boolean\n  'format'?: 'groq-type-nodes' | string\n  'watch'?: boolean\n  'watch-patterns'?: string | string[]\n}\n\nexport default async function extractAction(\n  args: CliCommandArguments<ExtractFlags>,\n  context: CliCommandContext,\n): Promise<void> {\n  const flags = args.extOptions\n\n  if (flags.watch) {\n    return runWatchMode(args, context)\n  }\n\n  return runSingleExtraction(args, context)\n}\n\nexport function getExtractOptions(\n  flags: ExtractFlags,\n  config: CliCommandContext['cliConfig'],\n  workDir: string,\n) {\n  const schemaExtraction = config?.schemaExtraction\n\n  return {\n    workspace: flags.workspace ?? schemaExtraction?.workspace,\n    format: flags.format ?? 'groq-type-nodes',\n    enforceRequiredFields:\n      flags['enforce-required-fields'] ?? schemaExtraction?.enforceRequiredFields ?? false,\n    outputPath: flags.path ?? schemaExtraction?.path ?? join(workDir, 'schema.json'),\n    watchPatterns: flags['watch-patterns']\n      ? Array.isArray(flags['watch-patterns'])\n        ? flags['watch-patterns']\n        : [flags['watch-patterns']]\n      : (schemaExtraction?.watchPatterns ?? []),\n  }\n}\n\n/**\n * Runs a single extraction with spinner and telemetry (original behavior).\n */\nasync function runSingleExtraction(\n  args: CliCommandArguments<ExtractFlags>,\n  context: CliCommandContext,\n): Promise<void> {\n  const flags = args.extOptions\n  const {workDir, output, telemetry, cliConfig} = context\n  const {\n    format,\n    enforceRequiredFields,\n    outputPath,\n    workspace: workspaceName,\n  } = getExtractOptions(flags, cliConfig, workDir)\n\n  const spinner = output\n    .spinner({})\n    .start(\n      enforceRequiredFields\n        ? 'Extracting schema, with enforced required fields'\n        : 'Extracting schema',\n    )\n\n  const trace = telemetry.trace(SchemaExtractedTrace)\n  trace.start()\n\n  try {\n    const schema = await extractSchemaToFile({\n      workDir,\n      outputPath,\n      workspaceName,\n      enforceRequiredFields,\n      format,\n    })\n\n    trace.log({\n      schemaAllTypesCount: schema.length,\n      schemaDocumentTypesCount: schema.filter((type) => type.type === 'document').length,\n      schemaTypesCount: schema.filter((type) => type.type === 'type').length,\n      enforceRequiredFields,\n      schemaFormat: format,\n    })\n\n    trace.complete()\n\n    spinner.succeed(\n      enforceRequiredFields\n        ? `Extracted schema to ${outputPath} with enforced required fields`\n        : `Extracted schema to ${outputPath}`,\n    )\n  } catch (err) {\n    trace.error(err)\n    spinner.fail(\n      enforceRequiredFields\n        ? 'Failed to extract schema, with enforced required fields'\n        : 'Failed to extract schema',\n    )\n\n    // Display validation errors if available\n    if (err instanceof SchemaExtractionError && err.validation && err.validation.length > 0) {\n      output.print('')\n      output.print(formatSchemaValidation(err.validation))\n    }\n\n    throw err\n  }\n}\n\n/**\n * Runs schema extraction in watch mode, re-extracting on file changes.\n */\nasync function runWatchMode(\n  args: CliCommandArguments<ExtractFlags>,\n  context: CliCommandContext,\n): Promise<void> {\n  const flags = args.extOptions\n\n  // Keep the start time + some simple stats for extractions as they happen\n  const startTime = Date.now()\n  const stats: {successfulDurations: number[]; failedCount: number} = {\n    successfulDurations: [],\n    failedCount: 0,\n  }\n\n  const {workDir, output, telemetry, cliConfig} = context\n  const options = getExtractOptions(flags, cliConfig, workDir)\n  const {\n    format,\n    enforceRequiredFields,\n    outputPath,\n    watchPatterns: additionalPatterns,\n    workspace: workspaceName,\n  } = options\n  const watchPatterns = [...DEFAULT_WATCH_PATTERNS, ...additionalPatterns]\n\n  const trace = telemetry.trace(SchemaExtractionWatchModeTrace)\n  trace.start()\n\n  // Print watch mode header and patterns at the very beginning\n  output.print('Schema extraction watch mode')\n  output.print('')\n  output.print('Watching for changes in:')\n  for (const pattern of watchPatterns) {\n    output.print(`  - ${pattern}`)\n  }\n  output.print('')\n\n  output.print('Running initial extraction...')\n\n  // Start the watcher (includes initial extraction)\n  const {stop} = await startSchemaWatcher({\n    workDir,\n    outputPath,\n    output,\n    workspaceName,\n    enforceRequiredFields,\n    format,\n    patterns: watchPatterns,\n    onExtraction: ({success, duration}) => {\n      if (success) {\n        stats.successfulDurations.push(duration)\n      } else {\n        stats.failedCount++\n      }\n    },\n  })\n\n  trace.log({\n    step: 'started',\n    enforceRequiredFields,\n    schemaFormat: format,\n  })\n\n  output.print('')\n  output.print('Watching for changes... (Ctrl+C to stop)')\n\n  const {resolve, promise} = promiseWithResolvers<void>()\n\n  /**\n   * Handle graceful shutdown. Wrapped in once to prevent it being called twice by the\n   * SIGINT/SIGTERM callbacks, causing double trace logs etc..\n   */\n  const cleanup = once(() => {\n    trace.log({\n      step: 'stopped',\n      watcherDuration: Date.now() - startTime,\n      averageExtractionDuration: mean(stats.successfulDurations),\n      extractionSuccessfulCount: stats.successfulDurations.length,\n      extractionFailedCount: stats.failedCount,\n    })\n    trace.complete()\n\n    output.print('')\n    output.print('Stopping watch mode...')\n    void stop()\n    resolve()\n  })\n\n  process.on('SIGINT', cleanup)\n  process.on('SIGTERM', cleanup)\n\n  // Keep process alive\n  await promise\n}\n"],"names":["SchemaExtractedTrace","defineTrace","name","version","description","SchemaExtractionWatchModeTrace","DEFAULT_WATCH_PATTERNS","IGNORED_PATTERNS","createExtractionRunner","onExtract","state","isExtracting","pendingExtraction","runExtraction","createSchemaWatcher","options","workDir","patterns","debounceMs","output","debouncedExtract","debounce","absolutePatterns","map","pattern","path","isAbsolute","join","watcher","chokidar","watch","ignoreInitial","ignored","cwd","on","event","filePath","timestamp","Date","toLocaleTimeString","relativePath","relative","print","err","error","Error","message","String","__dirname","dirname","fileURLToPath","import","url","SchemaExtractionError","constructor","validation","extractSchemaToFile","outputPath","workspaceName","enforceRequiredFields","format","rootPkgPath","readPkgUp","sync","workerPath","worker","Worker","workerData","env","process","Promise","resolve","reject","addListener","type","writeFile","JSON","stringify","schema","startSchemaWatcher","onExtraction","spinnerText","successText","spinner","start","startTime","now","success","duration","succeed","fail","length","formatSchemaValidation","stop","close","extractAction","args","context","extOptions","runWatchMode","runSingleExtraction","getExtractOptions","flags","config","schemaExtraction","workspace","watchPatterns","Array","isArray","telemetry","cliConfig","trace","log","schemaAllTypesCount","schemaDocumentTypesCount","filter","schemaTypesCount","schemaFormat","complete","stats","successfulDurations","failedCount","additionalPatterns","push","step","promise","promiseWithResolvers","cleanup","once","watcherDuration","averageExtractionDuration","mean","extractionSuccessfulCount","extractionFailedCount"],"mappings":"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"}